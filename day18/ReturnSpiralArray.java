package day18;

//양의 정수 n이 매개변수
//n × n 배열에 1부터 n^2 까지의 정수를 
//인덱스 [0][0]부터 시계방향 나선형으로 배치한 이차원 배열을 리턴

//예시
//n : 4
//[[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]]
//[1,	 2,		 3,		 4]
//[12,	 13,	 14,	 5]
//[11,	 16,	 15,	 6]
//[10,	 9,		 8,		 7]
public class ReturnSpiralArray {

	public int[][] solution(int n) {
		int[][] answer = new int[n][n];
		// 이번 문제는 출력이 아닌 입력
		// 가로 입력과 세로 입력을 따로 하면 될 듯
		// answer[0][0]부터 answer[0][n]까지 1~n을 채워넣음
		// answer[0][n]부터 answer[n][n]까지 n~5개의 정수를 채워넣음
		// answer[n][n]부터 answer[n][0]까지 2n-1부터 5개의 정수를 채워넣음
		// answer[n][0]부터 answer[n-1][0]까지 5개의 정수
		// 그 후 나선의 크기를 하나씩 줄여가며 반복

		// 1 2 3
		// 8 4
		// 7 6 5

		//
		// 9
		//
		// n이 3일 땐 두 바퀴의 나선이 생성됨

		// 1 2 3 4
		// 12 5
		// 11 6
		// 10 9 8 7

		//
		// 13 14
		// 16 15
		//
		// n이 4일 땐 두 바퀴의 나선이 생성됨

		// 1 2 3 4 5
		// 16 6
		// 15 7
		// 14 8
		// 13 12 11 10 9

		//
		// 17 18 19
		// 24 20
		// 23 22 21
		//

		//
		//
		// 25
		//
		//
		// n이 5일 땐 3바퀴의 나선이 생성됨

		// 1 	2 	3 	4 	5	 6
		// 20					 7
		// 19					 8
		// 18 					 9
		// 17 					 10
		// 16  15  14  13 	12 	 11

		//
		// 21 	22 		23 		24
		// 32 					25
		// 31 					26
		// 30 	29 		28		27
		//

		//
		//
		// 33 34
		// 36 35
		//
		//
		// n이 6일 땐 세 바퀴의 나선이 생성됨
		
		int s = 1;
		//각 인덱스에 저장할 숫자. ++ 연산자로 n까지 늘어남
		int cnt = 0;
		//나선을 몇 개 만들지 결정. n을 2로 나눈 후 올림한 값이 반복횟수가 됨
		
		if(n%2==0) {
			cnt = n/2;
		}else {
			answer[n/2][n/2]=n*n;
			//for문의 조건 상 정가운데의 인덱스는 채울 수 없음. 따라서 따로 지정
			cnt = n/2+1;
		}
		
		
		for (int i = 0; i < cnt; i++) {
			//각 변에서 1이 모자란 수만큼 채우고 있다. 따라서 n 대신 n-1을 사용
			//길이가 4인 정사각형이라면 3만, 5인 정사각형이라면 4만...
			//00001
			//34451
			//37051
			//37661
			//32222
			//이런 모습
			
			//-1과 +1 모두 i로 처리 중. 
			//시작점이 늘어나는 곳은 i를 시작점으로
			//종착점이 늘어나는 곳은 i를 끝점으로
			//왼쪽->오른쪽. 시작점 + 1, 종착점 -1
			//n:4 (0,0)(0,1)(0,2) //(1,1)
			//n:5 (0,0)(0,1)(0,2)(0,3) //(1,1)(1,2)// (2,2)
			for (int j = i; j < n-1-i; j++) {
				answer[i][j] = s++;
			}
			//위쪽 가로줄을 처리하는 반복문. 왼쪽 위 끝~오른쪽 위 끝 앞부분까지
			//행이 고정된 상태니, 앞부분을 i로 설정
			
			//위->아래. 시작점 + 1, 종착점 -1
			//n:4 (0,3)(1,3)(2,3) //(1,2)
			//n:5 (0,4)(1,4)(2,4)(3,4) //(1,3)(2,3)// (2,2)
			for (int j = i; j < n-1-i; j++) {
				answer[j][n-1-i] = s++;
			}
			//오른쪽 세로줄을 처리하는 반복문. 오른쪽 위 끝~오른쪽 아래 윗부분까지
			//열이 고정된 상태니, 뒷부분을 i로 설정
			//n-1-i = 가장 오른쪽부터 시작해 한 칸씩 안으로 들어가는 중
			//배열 크기와 인덱스가 다르기 때문에 n-1을 사용 
			
			//오른쪽->왼쪽. 시작점 - 1, 종착점 +1
			//n:4 (3,3)(3,2)(3,1) //(2,2)
			//n:5 (4,4)(4,3)(4,2)(4,1) //(3,3)(3,2)// (2,2)
			for (int j = n - i - 1; j > i; j--) {
				answer[n - 1 - i][j] = s++;
			}
			//아래 가로줄을 처리하는 반복문. 오른쪽 아래 끝 ~ 왼쪽 아래 끝 앞까지
			//행이 고정된 상태니, 앞부분을 i로 설정
			//n-1-i = 가장 아래쪽부터 시작해 한 칸씩 안으로 들어가는 중
			
			//아래->위. 시작점 - 1, 종착점 +1
			//n:4 (3,0)(2,0)(1,0) //(2,1)
			//n:5 (4,0)(3,0)(2,0)(1,0) //(3,1)(2,1)// (2,2)
			for (int j = n - i - 1; j > i; j--) {
				answer[j][i] = s++;
			}
			//왼쪽 세로줄을 처리하는 반복문. 왼쪽 아래 끝 ~ 왼쪽 위 끝 앞까지
			//열이 고정된 상태니, 뒷부분을 i로 설정
		}
		
		//세로줄을 담당하는 반복문과 가로줄을 담당하는 반복문은 서로 대칭이다
		
		// 모든 부분에서 공통적으로,
		// 다음 나선으로 진입할 때 시작점이 1 늘고 종착점이 1 줄어드는 중
		// 역순으로 처리하는 경우(오른쪽->왼쪽/아래->위) 시작점이 1 줄고 종착점 + 1
		// 1씩 늘고 주는 것을 i로 처리. 나선은 n/2를 올림한 값까지 반복됨. i최대값.
		
		// n이 5일 경우
		// 첫 번째 나선
		// (0,0)(0,1)(0,2)(0,3)
		// (0,4)(1,4)(2,4)(3,4)
		// (4,4)(4,3)(4,2)(4,1)
		// (4,0)(3,0)(2,0)(1,0)
		// 두 번째 나선
		// (1,1)(1,2)
		// (1,3)(2,3)
		// (3,3)(3,2)
		// (3,1)(2,1)
		// 마지막 나선
		// (2,2)

		// (0,0)(0,1)(0,2)(0,3) //(1,1)(1,2)
		// (0,4)(1,4)(2,4)(3,4) //(1,3)(2,3)
		// (4,4)(4,3)(4,2)(4,1) //(3,3)(3,2)
		// (4,0)(3,0)(2,0)(1,0) //(3,1)(2,1)
		// (2,2)

		// n이 4일 경우
		// 첫 번째 나선
		// (0,0)(0,1)(0,2)
		// (0,3)(1,3)(2,3)
		// (3,3)(3,2)(3,1)
		// (3,0)(2,0)(1,0)
		// 두 번째 나선
		// (1,1)
		// (1,2)
		// (2,2)
		// (2,1)

		// (0,0)(0,1)(0,2) //(1,1)
		// (0,3)(1,3)(2,3) //(1,2)
		// (3,3)(3,2)(3,1) //(2,2)
		// (3,0)(2,0)(1,0) //(2,1)

		// 모든 부분에서 공통적으로,
		// 다음 나선으로 진입할 때 시작점이 1 늘고 종착점이 1 줄어드는 중
		// 역순으로 처리하는 경우(오른쪽->왼쪽/아래->위) 시작점이 1 줄고 종착점 + 1

		return answer;
	}
}
