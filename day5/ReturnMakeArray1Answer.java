package day5;

import java.util.ArrayList;

//분명히 더 효율적인 방법이 있을 것
public class ReturnMakeArray1Answer {
	
//	public int[] solution(int l, int r) {
//
//        ArrayList<Integer> list = new ArrayList<>();
//
//        for (int i = 1; i < 64; i++) {
//            int num = Integer.parseInt(Integer.toBinaryString(i)) * 5;
//			  toBinaryString 메소드는 해당 수를 이진수로 치환한 후 문자열로 변환해 준다
//			  그 숫자를 다시 int형으로 바꾼 후, 5를 곱해 변수 num에 저장
	
//			  왜 이진수에 5를 곱하는가? i의 범위를 살펴보자
//			  1 이상 63(2의 5제곱-1) 이하. 이진수로 변환하면, 1~11111의 범위
//			  여기에 각각 5를 곱해주면 5~55555가 됨.
//			  하지만 이건 십진수를 활용한 단순 계산이지 정확한 수치는 아님
//			  이진수의 특성을 생각해보자. 하나의 자릿수에 두 개의 숫자밖에 존재하지 못하기에
//			  0->1->10->11->100->101->110->111의 순서대로 커진다
//			  이러한 형태는 문제가 제시한 5 또는 0으로 이루어진 수에 완벽하게 부합하는 형태이며
//			  이진수에 5를 곱해준다면 해당 조건을 전부 커버할 수 있게 된다
//			  따라서 문제의 제한사항(자릿수 등)을 고려해 i의 범위를 정해주기만 하면 된다
//			  본 문제에서는 1,000,000을 최대치로 설정해뒀음
	
//			  자릿수 부분은 좀 더 쉬운 코드를 통해 확인해보자
//			  이진수에서 지수는 곧 자릿수 - 1(0과 1일 때는 제외. 두 경우는 한 자리)을 의미한다
//    		  즉,8은 2의 3제곱이기에 네자리 수가 되고, 16은 다섯 자리가 되는 것
//			  이러한 특성을 이용하면 자릿수를 파악할 수 있게 된다
//    		  int digit = String.valueOf(r).length();
//			  r을 문자열로 바꿔서 자릿수를 알아낸다
//    		  int exponent = (int)Math.pow(2.0, digit);
//			  그 후 pow함수를 통해 2를 r의 자릿수만큼 거듭제곱해준다
//			  즉,exponent는 십진수 상에서의 범위를 제한하기 위한 변수
//			  쉽게 생각하면, 십진수끼리 비교한다면 r이 얼마든 그 수의 자릿수 이상까지는
//			  탐색할 이유가 없을 것이다. 이를 이진수에도 적용시키기 위한 방편이라 생각하자
//			  r을 백만이라 해보자. 백만은 7자리 수이다. 아무리 큰 수라 해도 7자리를 넘진 않을 것
//			  이는 이진수일 때도 마찬가지다. 다만 i값은 일단은 십진수이기에 
//			  List<Integer> list = new ArrayList<>();
//			  for (int i = 0; i < exponent; i++) {
//			  i는 아직 십진수이다. 문제에서는 l 이상 r 이하의 수 중에서 탐색을 요구
//			  즉, r보다 큰 수가 있어서는 안된다. 이때 십진수의 범위를 제한하기 위해서는
//			  자릿수를 쓰는 게 제일 좋다. 2를 digit만큼 거듭제곱하면 이진수 변환시에도
//			  같은 자릿수가 된다
//			  으음...그런데 <=이 아니라 <을 쓰는 이유는 잘 모르겠네...
//			  0부터 2를 r의 자릿수만큼 거듭해준 수 미만까지 반복
//			  String binaryString = Integer.toBinaryString(i);
//			  그 수를 전부 2진수로 변환시킨다
//			  int target = Integer.parseInt(binaryString) * 5;
//			  그 후 여기에 5를 곱한 값들을 target에 저장
//			  if (target >= l && target <= r)
//			  list.add(target);
//			  target이 l 이상 r 이하일 때만 list에 저장
//			  }
	
//			  
//			  마지막으로 l과 r 사이에 존재하는 5와 이진수를 곱한 값을 전부 찾아내면 완료
//			  이진수는 나무 모양으로 뻗어나간다. 자릿수가 하나인 수는 하나
//			  둘인 수는 둘, 셋인 수는 넷, 넷인 수는 여덟.....
//			  
//			  
//            if (l <= num && num <= r)
//                list.add(num);
//        }
//
//        return list.isEmpty() ? new int[] { -1 } : list.stream().mapToInt(i -> i).toArray();
//    }
//이진수를 이용한 풀이법. 

}
