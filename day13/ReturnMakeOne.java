package day13;

//정수가 있을 때, 짝수라면 반으로 나누고, 홀수라면 1을 뺀 뒤 반으로 나누면, 마지막엔 1이 됨
//num_list 배열의 모든 원소가 1이 되려면 몇 번의 연산이 필요한지 구해서 리턴

//해당 연산은 이진수를 1로 만드는 방법과 완전히 일치한다
//이진수를 2로 나누면 가장 왼쪽의 1(최상위 비트)가 사라진다. 즉, 자릿수가 하나 줄어든다
//이진수의 가장 오른쪽 자리가 1이라면 그 수는 홀수, 0이라면 짝수가 된다
//따라서 자릿수를 하나 감소시키기 위해선 짝수일 때 2로 나누고, 홀수일 때 1을 빼고 2로 나눠주면 된다
//이 작업을 오직 1만 남을 때까지 반복해주면 된다. 즉, 이진수의 자리-1(1은 남아야 하므로)이
//숫자를 1로 만들기 위한 연산의 횟수를 의미한다
public class ReturnMakeOne {

	public int solution(int[] num_list) {
		int answer = 0;

		for (int i = 0; i < num_list.length; i++) {
			num_list[i] = divide(num_list[i]);
			answer+=num_list[i];
			
//			이 코드를 대신 사용하는 것도 가능
//			사실 int형끼리의 연산에서 1을 빼줄 필요는 없다
//			어차피 정수부분만 남기기에. 0.5는 자동으로 내리는(빼주는) 것
//			그러니 1이 될 때까지 무한정 나눠준 후 그 반복횟수를 기록하면 된다
//			while(num_list[i]!=1){
//            num_list[i]/=2;
//            answer++;
//        }
		}
		
//		for(int i = 0; i < num_list.length; i++){
//            int j = 0;
//            while (num_list[i] >= Math.pow(2, j)) {
//                a = j;
//                j++;
//            }
//            answer += a;
//        }
//		이진수를 역으로 처리. 2의 j제곱이 더 커지는 시점까지 j를 늘린 후 그 값을 합산
		
		
		return answer;
		
		//이진수를 이용한 풀이법
//		 	return 
//		Arrays.stream(num_list)	해당 리스트를 스트림으로 변환
//		.map(i -> Integer.toBinaryString(i).length() - 1) 
//		스트림의 각 요소 i에 Integer.toBinaryString(i) 적용
//		해당 메소드는 i를 이진문자열(이진수를 문자열로 표현한 것)로 바꿔버림
//		.length()메소드로 이진문자열의 길이(자릿수)를 구할 수 있음. 거기서 1을 뺀 값을 최종적으로 리턴
//		.sum();	스트림 내부의 모든 원소들을 합산
		
//		문제에서 제시하고 있는 정수를 1로 만드는 연산은 이진수의 각 비트를 제거하는 방식과 굉장히 유사함
//		이때 1비트는 0,1 중 하나, 즉 이진수를 표기하는 용량. 즉 비트를 제거하는 것은 자릿수를 하나 없앤다는 것
//		이러한 현상은 이진수의 구조와 연산 규칙에서 비롯됨
		
//		이진수는 2의 거듭제곱을 기반으로 숫자를 표현. 예를 들어, 5는 101이 됨
//		이때 가장 왼쪽의 1(최상위 비트)는 가장 큰 값이며, 이진수의 값에 큰 영향을 미침
//		최상위 비트를 제거하기 위해선 2를 나눠주면 된다. 왜? 이진수는 2의 거듭제곱으로 표현된 숫자이기 때문
//		짝수인 6의 경우를 생각해보자. 이진수로 변환 시 110이 된다. 6을 2로 나누면 3
//		3은 이진수로 변환 시 11이 된다. 110->11. 최상위 비트가 제거된 모습이다
//		홀수의 최상위 비트를 제거하기 위해선? 우선 짝수로 만든 후 2로 나눠줘야 한다
//		이진수 홀수의 경우, 아무리 자릿수가 많아도 끝에 1이 무조건 붙게 된다
//		짝수에 1을 더하거나 빼야 홀수가 된다. 이진수의 두 번째 자리부터는 전부 2의 거듭제곱이다
//		즉, 111110은 짝수, 111111은 홀수라는 뜻. 여기서 1을 빼서 마지막 자릿수를
//		0으로 바꾸면 짝수가 된다. 여기서 2를 나누는 것으로 최상위 비트를 제거할 수 있다
//		이는 문제에서 주어진 연산과 일치하는 구조다. 이는 곧 최상위 비트를 전부 제거하고 1만을 남기는 작업이다.
//		110을 1로, 110101을 1로 바꾸는 작업. 즉 자릿수-1이 되는 것이다
		
//		이진수의 길이 n은 정수 x가 2^(n-1) 이상 2^n 미만인 범위에 있다
//		정확히는 로그값이라는데..n = (int)(Math.log(x) / Math.log(2)) + 1
	}

	private int divide(int i) {

		int count = 0;
		boolean stop = true;

		while (stop) {
			if (i % 2 == 0) {
				i /= 2;
				count += 1;
			} else if (i % 2 == 1 && i != 1) {
				i = (i - 1) / 2;
				count += 1;
			} else {
				stop = false;
			}
		}
		return count;
	}
}
